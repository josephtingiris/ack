#!/bin/bash

PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin
if [ "$DEBUG" == "" ]; then
    declare -i DEBUG=##ACK_CLIENT_DEBUG##
else
    declare -i DEBUG=$DEBUG
fi

echo
echo "ack-template-ppi"
echo

CONSOLE="##ACK_CLIENT_CONSOLE##"

# defaults are (were) primarily used for development inside the initrd shell, before fully realizing the power of
# using a dynamic ks config, which is made capable by relying on an http server & a server side scripting engine
# (e.g. mod_php or mod_wsgi).  hindsight ... a better, easier/faster & more realistic way to develop is to curl
# this (ack-ppi) within initrd via the ack http server and let it do the ##X## replacements

DEFAULT_ACK_LABEL="##ACK_LABEL##"

DEFAULT_ANA_INSTALL_PATH=/mnt/sysimage

DEFAULT_CLIENT_BUILD_URI="##ACK_CLIENT_BUILD_URI##"
DEFAULT_CLIENT_BUILD_URL="##ACK_CLIENT_BUILD_URL##"

DEFAULT_DIR_EFI_BOOT="/boot/efi"
DEFAULT_DIR_MEDIA="/tmp/media"
DEFAULT_DIR_RECOVERY="/tmp/recovery"

DEFAULT_INSTALL_DOMAIN="##ACK_INSTALL_DOMAIN##"
DEFAULT_INSTALL_ID="##ACK_ID##"
DEFAULT_INSTALL_SERVER="##ACK_INSTALL_SERVER##"
DEFAULT_INSTALL_SERVERS=##ACK_INSTALL_SERVERS##
DEFAULT_INSTALL_SSH_AUTHORIZED_KEYS=##ACK_SSH_AUTHORIZED_KEYS##

DEFAULT_RECOVERY_INITRD="/initrd.img"
DEFAULT_RECOVERY_VMLINUZ="/vmlinuz inst.ks.sendmac inst.ks.sendsn inst.ks=https://$DEFAULT_INSTALL_SERVER/ noverifyssl inst.sshd console=##ACK_CLIENT_CONSOLE## inst.syslog=$DEFAULT_INSTALL_SERVER BOOT_IMAGE=vmlinuz"

DEFAULT_SUPPORTED_DEVICES=""
DEFAULT_SUPPORTED_DEVICES+="$(echo /dev/vd{a..z})"
DEFAULT_SUPPORTED_DEVICES+=" "
DEFAULT_SUPPORTED_DEVICES+="$(echo /dev/hd{a..z})"
DEFAULT_SUPPORTED_DEVICES+=" "
DEFAULT_SUPPORTED_DEVICES+="$(echo /dev/sd{a..z})"

if [ $DEBUG -gt 100 ]; then
    DEFAULT_SMARTPART=/tmp/smartpart.pre_install
else
    DEFAULT_SMARTPART=/tmp/smartpart
fi

declare -i EFI_STATE=0

declare -i ERROR_COUNT=0
declare -i ERROR_LEVEL=0

declare -i INSTALL_DISK_PERCENT=100
declare -i INSTALL_STATE=0

declare -i RETRY_COUNT=0
declare -i RETRY_MAXIMUM=3

VERSION=0.1

declare -i WARNING_COUNT=0

# Functions

function _Block_Dev() {
    Debug "_Block_Dev() begin" 1000

    local failure_state=0

    if [ "$1" == "" ]; then
        Warning "$FUNCNAME block_dev = NULL"
        failure_state=1
    else
        local block_dev="$1"
    fi

    sync
    if [ -a "${block_dev}" ]; then
        if [ -b "${block_dev}" ]; then
            return 0
        else
            Warning "${block_dev} exists but is not a block device"
            return 1
        fi
    else
        Debug "${block_dev} block device not found" 44
    fi

    Debug "_Block_Dev() end" 1000

    return 1
}

function _Chmod() {
    Debug "_Chmod() begin" 1000

    local failure_state=0

    if [ "$2" == "" ]; then
        Warning "$FUNCNAME file = NULL"
        failure_state=1
    else
        local file="$2"
    fi

    if [ "$1" == "" ]; then
        Warning "$FUNCNAME permissions = NULL"
        failure_state=1
    else
        local -i permissions="$1"
    fi

    if [ $failure_state -eq 0 ]; then
        chmod $permissions "$file"
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "chmod $permissions $file succeeded" 3
        else
            Warning "chmod $permissions $file failed [$exit_code]"
        fi
    fi

    Debug "_Chmod() end" 1000
}

function _Cp() {
    Debug "_Cp() begin" 1000

    local failure_state=0

    if [ "$1" == "" ]; then
        Warning "$FUNCNAME copy_from = NULL"
        failure_state=1
    else
        local copy_from="$1"
    fi

    if [ ! -f "$copy_from" ]; then
        Warning "$FUNCNAME $copy_from file not found"
        failure_state=1
    fi

    if [ "$2" == "" ]; then
        Warning "$FUNCNAME copy_to = NULL"
        failure_state=1
    else
        local copy_to="$2"
    fi

    if [ $failure_state -eq 0 ]; then
        cp "$copy_from" "$copy_to"
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "cp $copy_from $copy_to succeeded" 200
        else
            Warning "cp $copy_from $copy_to failed [$exit_code]"
        fi
    fi

    Debug "_Cp() end" 1000
}

function _Mkdir() {
    Debug "_Mkdir() begin" 1000

    local failure_state=0

    if [ "$1" == "" ]; then
        Warning "$FUNCNAME directory = NULL"
        failure_state=1
    else
        local directory="$1"
    fi

    if [ -d "$directory" ]; then
        Debug "$FUNCNAME $directory directory exists" 200
        failure_state=1
    fi

    if [ $failure_state -eq 0 ]; then
        mkdir -p "$directory"
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "mkdir -p $directory succeeded" 3
        else
            Warning "mkdir -p $directory failed [$exit_code]"
        fi
    fi

    Debug "_Mkdir() end" 1000
}

function _Reboot() {
    Debug "_Reboot() begin" 1000

    if [ "$USER" == "" ] && [ $DEBUG -eq 0 ]; then
        Debug "boot forced"

        local -i vt=$(echo "$CONSOLE" | awk -F\/ '{print $NF}' | sed -e '/tty/s///g')
        if [ $vt -ne 0 ]; then chvt $vt; fi

        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        sleep 2
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        sleep 2
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        echo -ne '\007' > /dev/$CONSOLE; sleep 1
        sleep 2

        reboot -f
    else
        if [ "$USER" == "" ]; then USER="anonymous"; fi
        Debug "boot avoided (DEBUG=$DEBUG, USER=$USER)" 2
    fi

    Debug "_Reboot() end" 1000
}

function _Rm() {
    Debug "_Rm() begin" 1000

    local failure_state=0

    if [ "$1" == "" ]; then
        Warning "$FUNCNAME file = NULL"
        failure_state=1
    else
        local file="$1"
    fi

    if [ ! -f "$file" ]; then
        Debug "$FUNCNAME $file file doesn't exist" 200
        failure_state=1
    fi

    if [ $failure_state -eq 0 ]; then
        if [ -d "$file" ]; then
            local file_type="directory"
            rm -rf "$file"
        else
            local file_type="file"
            rm -f "$file"
        fi
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "rm $file ($file_type) succeeded" 2
        else
            Warning "rm $file ($file_type) failed [$exit_code]"
        fi
    fi

    Debug "_Rm() end" 1000
}

function Debug() {
    if [ "$1" == "" ]; then
        local debug_message=""
    else
        local debug_message="$1"
    fi

    if [ "$2" == "" ] || [ "$2" == "0" ]; then
        local -i debug_level=0
    else
        local -i debug_level=$2
    fi

    if [ "$3" == "" ] || [ "$3" == "0" ]; then
        local -i line_number=0
    else
        local -i line_number=$3
    fi

    if [ $debug_level -eq 0 ] || [ $debug_level -le $DEBUG ]; then
        if [ $debug_level -ne 0 ]; then
            debug_message="[$(date +%H%M%S)] [$RETRY_COUNT] [$0] [$debug_level] : $debug_message"
        fi
        if [ $line_number -ne 0 ]; then
            debug_message+=" [line $line_number]"
        fi
        echo "$debug_message" | tee /dev/$CONSOLE
    fi
}

function Debug_Content() {
    Debug "Debug_Content() begin" 1000

    if [ "$1" == "" ]; then return; fi
    if [ -d "$1" ]; then return; fi
    if [ -b "$1" ]; then return; fi
    if [ ! -s "$1" ]; then return; fi

    if [ "$2" != "" ]; then
        local -i debug_content_level="$2"
    else
        local -i debug_content_level=100
    fi

    if [ -f "$1" ] && [ $DEBUG -gt $debug_content_level ]; then
        local debug_content=$(cat "$1")
        if [ "$debug_content" != "" ]; then
            Debug "" $debug_content_level
            Debug "content of $1" $debug_content_level
            Debug "" $debug_content_level
            echo "${debug_content}" | tee /dev/$CONSOLE
            Debug "" $debug_content_level
        fi
    fi

    Debug "Debug_Content() begin" 1000
}

function Error() {
    Debug "Error() begin" 1000

    if [ "$2" != "" ]; then
        ERROR_LEVEL=$2
    else
        let ERROR_LEVEL=$ERROR_LEVEL+1
    fi

    let ERROR_COUNT=$ERROR_COUNT+1

    if [ $ERROR_LEVEL -ne 0 ] && [ $ERROR_COUNT -lt 10 ]; then
        if [ "$1" == "" ]; then
            local error_message="unknown"
        else
            local error_message="$1"
        fi
        Debug "" 0
        Debug "ERROR[$ERROR_LEVEL/$ERROR_COUNT], $error_message" 0
        Debug "" 0

        if [ $ERROR_COUNT -lt 5 ]; then Void "$EPHEMERAL_DIRS" false; fi

        _Reboot

        exit $ERROR_LEVEL
    fi

    Debug "Error() end" 1000
}

function Init_Ack() {
    Debug "Init_Ack() begin" 1000

    if [ -f /etc/redhat-release ]; then
        REDHAT_RELEASE=$(cat /etc/redhat-release)
        if [ "$REDHAT_RELEASE" == "" ]; then
            Error "/etc/redhat-release is empty"
        fi
        Debug "REDHAT_RELEASE = $REDHAT_RELEASE" 2
    else
        Error "can't find /etc/redhat-release"
    fi

    if [ $DEBUG -gt 100 ]; then
        clear
    fi

    CONSOLE=$(echo "$CONSOLE" | awk -F, '{print $1}')
    Debug "CONSOLE = $CONSOLE" 2

    # bug workaround; dhclient doesn't start and/or crashes sometimes (rare). -jjt
    local dhclient_pid=$(pgrep dhclient 2> /dev/null)
    if [ "$dhclient_pid" == "" ]; then
        /sbin/dhclient
    fi

    if [ "$ACK_LABEL" == "" ]; then
        if [ "${DEFAULT_ACK_LABEL:0:2}" == "##" ] || [ "${DEFAULT_ACK_LABEL}" == "" ]; then
            export ACK_LABEL="ack"
            Debug "ACK_LABEL = $ACK_LABEL (hard-coded)" 2
        else
            export ACK_LABEL="$DEFAULT_ACK_LABEL"
            Debug "ACK_LABEL = $ACK_LABEL (default)" 2
        fi
    else
        Debug "ACK_LABEL = $ACK_LABEL" 2
    fi

    CURL_HEADERS="--header \"X-ACK_LABEL: ${ACK_LABEL}\""

    if [ "$ANA_INSTALL_PATH" == "" ]; then
        export ANA_INSTALL_PATH="$DEFAULT_ANA_INSTALL_PATH"
        Debug "ANA_INSTALL_PATH = $ANA_INSTALL_PATH (default)" 2
    else
        Debug "ANA_INSTALL_PATH = $ANA_INSTALL_PATH" 2
    fi

    if [ "$DIR_EFI_BOOT" == "" ]; then
        export DIR_EFI_BOOT="$DEFAULT_DIR_EFI_BOOT"
        Debug "DIR_EFI_BOOT = $DIR_EFI_BOOT (default)" 2
    else
        Debug "DIR_EFI_BOOT = $DIR_EFI_BOOT" 2
    fi

    CURL_HEADERS+=" --header \"X-DIR-EFI-BOOT: ${DIR_EFI_BOOT}\""

    if [ "$DIR_MEDIA" == "" ]; then
        export DIR_MEDIA="$DEFAULT_DIR_MEDIA"
        Debug "DIR_MEDIA = $DIR_MEDIA (default)" 2
    else
        Debug "DIR_MEDIA = $DIR_MEDIA" 2
    fi

    if [ "$DIR_RECOVERY" == "" ]; then
        export DIR_RECOVERY="$DEFAULT_DIR_RECOVERY"
        Debug "DIR_RECOVERY = $DIR_RECOVERY (default)" 2
    else
        Debug "DIR_RECOVERY = $DIR_RECOVERY" 2
    fi

    if [ -d /sys/firmware/efi ]; then
        EFI_STATE=0
        GRUB2_TARGET=x86_64-efi
        RECOVERY_DIRS="grub EFI isolinux"
        Debug "EFI_STATE = $EFI_STATE (EFI)" 2
    else
        EFI_STATE=1
        GRUB2_TARGET=i386-pc
        RECOVERY_DIRS="isolinux"
        Debug "EFI_STATE = $EFI_STATE (bios)" 2
    fi

    CURL_HEADERS+=" --header \"X-EFI-STATE: ${EFI_STATE}\""

    CURL_HEADERS+=" --header \"X-HOSTNAME: $(hostname)\""

    if [ "$EPHEMERAL_DIRS" == "" ]; then
        export EPHEMERAL_DIRS="$DIR_MEDIA $DIR_RECOVERY"
        Debug "EPHEMERAL_DIRS = $EPHEMERAL_DIRS (default)" 2
    else
        Debug "EPHEMERAL_DIRS = $EPHEMERAL_DIRS" 2
    fi

    if [ "$SUPPORTED_DEVICES" == "" ]; then
        export SUPPORTED_DEVICES="$DEFAULT_SUPPORTED_DEVICES"
        Debug "SUPPORTED_DEVICES = $SUPPORTED_DEVICES (default)" 2
    else
        Debug "SUPPORTED_DEVICES = $SUPPORTED_DEVICES" 2
    fi

    if [ "$INSTALL_ID" == "" ]; then
        if [ "${DEFAULT_INSTALL_ID:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_ID}" == "" ]; then
            export INSTALL_ID="smartstart"
            Debug "INSTALL_ID = $INSTALL_ID (smartstart)" 2
        else
            export INSTALL_ID="$DEFAULT_INSTALL_ID"
            Debug "INSTALL_ID = $INSTALL_ID (default)" 2
        fi
    else
        Debug "INSTALL_ID = $INSTALL_ID" 2
    fi
    CURL_HEADERS+=" --header \"X-INSTALL-ID: ${INSTALL_ID}\""

    local disk_label=/dev/disk/by-label
    local install_device=""

    if [ -d $disk_label ]; then
        # must match the label of the iso, usb, etc. (see: sbin/ack-iso [local volume_id])
        install_device=$(ls -1 -l $disk_label/${ACK_LABEL}-* 2> /dev/null)
        install_device="${install_device##*/}"
    else
        Error "$disk_label directory not found" 2
    fi

    if [ "$install_device" != "" ]; then
        Debug "install_device = $install_device" 2
        for supported_device in $SUPPORTED_DEVICES; do
            supported_device="${supported_device##*/}"
            if _Block_Dev "/dev/${supported_device}"; then
                if [ "$supported_device" != "$install_device" ]; then
                    Debug "$supported_device != $install_device" 4
                    # don't install to usb devices?; this list of possibilities is endless ... virtio? scsi?
                    #if (ls -1 -l /dev/disk/by-path | egrep -ve '-usb-' | grep -q "/${supported_device}$"); then

                    # install to the first device that has valid media? (that's not the install_device)
                    if (fdisk -l /dev/${supported_device} &> /dev/null); then
                        DEFAULT_INSTALL_DISK="${supported_device##*/}"
                        Debug "DEFAULT_INSTALL_DISK = $DEFAULT_INSTALL_DISK" 2
                        break
                    fi
                fi
            fi
        done
    fi

    if [ "$INSTALL_DISK" == "" ]; then
        if [ "${DEFAULT_INSTALL_DISK:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_DISK}" == "" ]; then
            Error "INSTALL_DISK is not valid" 2
        else
            export INSTALL_DISK="$DEFAULT_INSTALL_DISK"
            Debug "INSTALL_DISK = $INSTALL_DISK (default)" 2
        fi
    else
        Debug "INSTALL_DISK = $INSTALL_DISK" 2
    fi

    if [ "$INSTALL_DISK" == "" ]; then
        Error "INSTALL_DISK = NULL" 2
    fi

    if ! _Block_Dev "/dev/${INSTALL_DISK}"; then
        Error "INSTALL_DISK ($INSTALL_DISK) is not a block device" 2
    fi

    CURL_HEADERS+=" --header \"X-INSTALL-DISK: ${INSTALL_DISK}\""

    if [ "$INSTALL_SERVER" == "" ]; then
        if [ "${DEFAULT_INSTALL_SERVER:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_SERVER}" == "" ]; then
            if [ -r /tmp/syslog ]; then
                export INSTALL_SERVER=$(grep Kernel\ command\ line: /tmp/syslog | awk -Finst.ks= '{print $2}' | awk '{print $1}' | awk -F\/ '{print $3}')
                Debug "INSTALL_SERVER = $INSTALL_SERVER (syslog)" 4
            fi
            if [ "$INSTALL_SERVER" == "" ] && [ -r /var/log/dmesg ]; then
                export INSTALL_SERVER=$(grep Kernel\ command\ line: /var/log/dmesg | awk -Finst.ks= '{print $2}' | awk '{print $1}' | awk -F\/ '{print $3}')
                Debug "INSTALL_SERVER = $INSTALL_SERVER (dmesg)" 4
            fi
            if [ "$INSTALL_SERVER" == "" ]; then
                export INSTALL_SERVER="localhost"
                Debug "INSTALL_SERVER = $INSTALL_SERVER (localhost)" 4
            fi
        else
            INSTALL_SERVER=$DEFAULT_INSTALL_SERVER
            Debug "INSTALL_SERVER = $INSTALL_SERVER (default)" 4
        fi
    else
        Debug "INSTALL_SERVER = $INSTALL_SERVER" 2
    fi

    CURL_HEADERS+=" --header \"X-INSTALL-SERVER: ${INSTALL_SERVER}\""

    if [ "$INSTALL_DOMAIN" == "" ]; then
        if [ "${DEFAULT_INSTALL_DOMAIN:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_DOMAIN}" == "" ]; then
            export INSTALL_DOMAIN="${INSTALL_SERVER#**.}"
            if [ "$INSTALL_DOMAIN" == "" ]; then
                export INSTALL_DOMAIN="localdomain"
                Debug "INSTALL_DOMAIN = $INSTALL_DOMAIN (localdomain)" 2
            else
                Debug "INSTALL_DOMAIN = $INSTALL_DOMAIN (derivative)" 4
            fi
        else
            export INSTALL_DOMAIN=$DEFAULT_INSTALL_DOMAIN
            Debug "INSTALL_DOMAIN = $INSTALL_DOMAIN (default)" 2
        fi
    else
        Debug "INSTALL_DOMAIN = $INSTALL_DOMAIN" 2
    fi

    CURL_HEADERS+=" --header \"X-INSTALL-DOMAIN: ${INSTALL_DOMAIN}\""

    if [ "$INSTALL_SERVERS" == "" ]; then
        if [ "${DEFAULT_INSTALL_SERVERS:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_SERVERS}" == "" ]; then
            INSTALL_SERVERS="$INSTALL_DOMAIN debug"
            Debug "INSTALL_SERVERS = $INSTALL_SERVERS (domain)" 2
        else
            INSTALL_SERVERS="$DEFAULT_INSTALL_SERVERS"
            Debug "INSTALL_SERVERS = $INSTALL_SERVERS (default)" 2
        fi
    else
        Debug "INSTALL_SERVERS = $INSTALL_SERVERS" 2
    fi

    ANA_INSTALL_MOUNT=$(mount 2>&1 | grep "$ANA_INSTALL_PATH")
    if [ "$ANA_INSTALL_MOUNT" == "" ]; then
        INSTALL_STATE=1
        Debug "INSTALL_STATE = $INSTALL_STATE ($ANA_INSTALL_PATH has no mounted filesystems)" 2
    else
        INSTALL_STATE=2
        Debug "INSTALL_STATE = $INSTALL_STATE ($ANA_INSTALL_PATH has mounted filesystems: $ANA_INSTALL_MOUNT)" 2
    fi

    if [ "$RECOVERY_INITRD" == "" ]; then
        export RECOVERY_INITRD="$DEFAULT_RECOVERY_INITRD"
        Debug "RECOVERY_INITRD = $RECOVERY_INITRD (default)" 2
    else
        Debug "RECOVERY_INITRD = $RECOVERY_INITRD" 2
    fi

    if [ "$RECOVERY_VMLINUZ" == "" ]; then
        export RECOVERY_VMLINUZ="$DEFAULT_RECOVERY_VMLINUZ"
        Debug "RECOVERY_VMLINUZ = $RECOVERY_VMLINUZ (default)" 2
    else
        Debug "RECOVERY_VMLINUZ = $RECOVERY_VMLINUZ" 2
    fi

    if [ "$SMARTPART" == "" ]; then
        export SMARTPART="$DEFAULT_SMARTPART"
        Debug "SMARTPART = $SMARTPART (default)" 2
    else
        Debug "SMARTPART = $SMARTPART" 2
    fi

    CURL_HEADERS+=" --header \"X-ANACONDA-ARCHITECTURE: $(uname -m)\""

    if [ -f /etc/redhat-release ]; then
        if [ -f /etc/centos-release ]; then
            CURL_HEADERS+=" --header \"X-ANACONDA-SYSTEM-RELEASE: CentOS\""
        else
            CURL_HEADERS+=" --header \"X-ANACONDA-SYSTEM-RELEASE: RedHat\""
        fi
    else
        CURL_HEADERS+=" --header \"X-ANACONDA-SYSTEM-RELEASE: $(uname -o)\""
    fi

    local install_server_ip=$(nslookup $INSTALL_SERVER | grep ^Address:\ [0-9] | awk '{print $NF}')
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "nslookup $INSTALL_SERVER succeeded" 200
    else
        Warning "nslookup $INSTALL_SERVER failed [$exit_code]"
    fi
    if [ "$install_server_ip" == "" ]; then
        Warning "install_server_ip = NULL"
    else
        Debug "install_server_ip = $install_server_ip" 2
    fi

    local provisioning_interface=$(ip -o route get $install_server_ip | awk -Fdev '{print $NF}' | awk '{print $1}')
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "ip route get $install_server_ip succeeded" 200
    else
        Warning "ip route get $install_server_ip failed [$exit_code]"
    fi

    if [ "$provisioning_interface" != "" ] && [ ! -L "/sys/class/net/$provisioning_interface" ] && [ ! -f "/sys/class/net/$provisioning_interface/address" ]; then
        Debug "provisioning_interface = INVALID" 2
    fi

    if [ "$provisioning_interface" == "" ]; then
        Debug "provisioning_interface = INVALID (NULL)" 2
    else
        Debug "provisioning_interface = $provisioning_interface" 2
    fi

    if [ "$provisioning_interface" != "" ] && [ -f "/sys/class/net/$provisioning_interface/address" ]; then
        local provisioning_mac=$(cat /sys/class/net/$provisioning_interface/address)
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "cat /sys/class/net/$provisioning_interface/address succeeded" 200
        else
            Debug "cat /sys/class/net/$provisioning_interface/address failed [$exit_code]" 2
        fi
    fi

    if [ "$provisioning_mac" == "" ]; then
        local provisioning_mac=$(ip -4 link list $provisioning_interface | grep link\/ | head -1 | awk '{print $2}')
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "ip link list $provisioning_interface succeeded" 200
        else
            Warning "ip link list $provisioning_interface failed [$exit_code]"
        fi
    fi

    if [ "$provisioning_mac" == "" ]; then
        Warning "provisioning_mac = NULL"
    else
        Debug "provisioning_mac = $provisioning_mac" 2
    fi

    CURL_HEADERS+=" --header \"X-RHN-PROVISIONING-MAC-0: $provisioning_interface $provisioning_mac\""

    local provisioning_ip=$(ip -4 -o addr list $provisioning_interface | head -1 | awk '{print $4}' | awk -F\/ '{print $1}')
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "ip addr list $provisioning_interface succeeded" 200
    else
        Warning "ip addr list $provisioning_interface failed [$exit_code]"
    fi

    if [ "$provisioning_ip" == "" ]; then
        Warning "provisioning_ip = NULL"
    else
        Debug "provisioning_ip = $provisioning_ip" 2
    fi

    CURL_HEADERS+=" --header \"X-PROVISIONING-IP-0: $provisioning_interface $provisioning_ip\""

    local system_serial_number=$(dmidecode -t system | grep Serial | head -1 | sed -e '/Serial Number:/s///g')
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "dmidecode system succeeded" 200
    else
        Debug "dmidecode system failed [$exit_code]" 2
    fi
    if [ "$system_serial_number" == "" ]; then
        system_serial_number="$provisioning_mac"
    fi
    Debug "system_serial_number = $system_serial_number" 2

    CURL_HEADERS+=" --header \"X-SYSTEM-SERIAL-NUMBER: $system_serial_number\""

    CURL_HEADERS=$(echo "$CURL_HEADERS" | sed -e "/\t/s// /g" -e "/ \+/s// /g")
    Debug "CURL_HEADERS = $CURL_HEADERS (appendix)" 2

    local ack_url="https://$INSTALL_SERVER/client/"
    local curl_tmp_file="/tmp/${INSTALL_SERVER}.tmp"
    local http_code=$(eval curl $CURL_HEADERS --write-out %{http_code} --silent -k "${ack_url}?id=${ACK_LABEL}\\&install_state=$INSTALL_STATE\\&install_id=$(Url_Encode "$INSTALL_ID")" -o $curl_tmp_file)
    if [ "$http_code" == "200" ]; then
        Debug "curl ${ack_url}?id=${ACK_LABEL}&install_state=$INSTALL_STAIDE&install_id=$(Url_Encode "$INSTALL_ID") -o $curl_tmp_file succeeded [$http_code]" 4
    else
        Error "curl ${ack_url}?id=${ACK_LABEL}ck&install_state=$INSTALL_STAIDE&install_id=$(Url_Encode "$INSTALL_ID") -o $curl_tmp_file failed [$http_code] [$exit_code]"
    fi

    Void

    Debug "Init_Ack() end" 1000
}

function Init_Authorized_Keys() {
    Debug "Init_Authorized_Keys() begin" 1000

    if [ "$INSTALL_SSH_AUTHORIZED_KEYS" == "" ]; then
        if [ "${DEFAULT_INSTALL_SSH_AUTHORIZED_KEYS:0:2}" == "##" ] || [ "${DEFAULT_INSTALL_SSH_AUTHORIZED_KEYS}" == "" ]; then
            local embedded_ssh_authorized_keys=$(cat <<EOF
            # $0 embedded key
EOF
)
export INSTALL_SSH_AUTHORIZED_KEYS="$embedded_ssh_authorized_keys"
Debug "INSTALL_SSH_AUTHORIZED_KEYS = $INSTALL_SSH_AUTHORIZED_KEYS (embedded)" 200
else
    export INSTALL_SSH_AUTHORIZED_KEYS=$DEFAULT_INSTALL_SSH_AUTHORIZED_KEYS
    Debug "INSTALL_SSH_AUTHORIZED_KEYS = $INSTALL_SSH_AUTHORIZED_KEYS (default)" 200
fi
else
    Debug "INSTALL_SSH_AUTHORIZED_KEYS = $INSTALL_SSH_AUTHORIZED_KEYS" 200
fi

local root_ssh_dir="$1"

if [ "$root_ssh_dir" == "" ]; then return; fi

if [ -f "$root_ssh_dir" ] || [ -h "$root_ssh_dir" ]; then
    Warning "$root_ssh_dir exists as a file or link"
    return
fi

Debug "Init_Authorized_Keys() $root_ssh_dir" 1

_Mkdir "$root_ssh_dir"

if [ ! -d "$root_ssh_dir" ]; then
    Warning "$root_ssh_dir directory not found"
else
    _Chmod 700 "$root_ssh_dir"
fi

if [ ! -f $root_ssh_dir/id_rsa ] && [ ! -f $root_ssh_dir/id_rsa.pub ]; then
    ssh-keygen -f $root_ssh_dir/id_rsa -t rsa -b 2048 -C '' -N ""
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "ssh-keygen -f $root_ssh_dir/id_rsa succeeded" 200
    else
        Warning "ssh-keygen -f $root_ssh_dir/id_rsa failed [$exit_code]"
    fi
fi

if [ "$INSTALL_SSH_AUTHORIZED_KEYS" != "" ]; then
    Debug "creating $root_ssh_dir/authorized_keys" 2
    > $root_ssh_dir/authorized_keys
    for INSTALL_SSH_AUTHORIZED_KEY in ${SSH_AUTHRIZED_KEYS[@]}; do
        echo "$INSTALL_SSH_AUTHORIZED_KEYS" >> $root_ssh_dir/authorized_keys
    done
    _Chmod 600 "$root_ssh_dir/authorized_keys"
    if [ $DEBUG -gt 100 ] && [ -f "$root_ssh_dir/authorized_keys" ]; then
        echo "----------------------------------------------------"
        cat "$root_ssh_dir/authorized_keys"
        echo "----------------------------------------------------"
        exit
    fi
else
    Debug "INSTALL_SSH_AUTHORIZED_KEYS = NULL" 2
fi

Debug "Init_Authorized_Keys() end" 1000
}

function Post_Install() {
    Debug "Post_Install() begin" 1000

    Init_Authorized_Keys "/root/.ssh"

    if [ -d "$ANA_INSTALL_PATH/sbin" ] && [ -d "$ANA_INSTALL_PATH/bin" ] && [ -d "$ANA_INSTALL_PATH/usr/bin" ] && [ -d "$ANA_INSTALL_PATH/usr/sbin" ]; then
        PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:$ANA_INSTALL_PATH/sbin:$ANA_INSTALL_PATH/bin:$ANA_INSTALL_PATH/usr/sbin:$ANA_INSTALL_PATH/usr/bin
        Debug "PATH=$PATH" 2
    else
        Warning "$ANA_INSTALL_PATH path directory not found"
        return
    fi

    setenforce permissive
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "setenforce permissive succeeded" 300
    else
        Warning "setenforce permissive failed [$exit_code]"
    fi

    if [ -d "$ANA_INSTALL_PATH/boot" ]; then
        local grub_cfgs=$(find "$ANA_INSTALL_PATH/boot" -name grub.cfg)
        for grub_cfg in $grub_cfgs; do
            local grub_cfg_dirname=$(dirname "$grub_cfg")
            if [ -f "$grub_cfg_dirname/custom.cfg" ]; then
                Debug "$grub_cfg_dirname/custom.cfg file found" 3
            else
                if [ -f /tmp/custom.cfg ]; then
                    # is the recovery set root correct?
                    _Cp "/tmp/custom.cfg" "$grub_cfg_dirname/custom.cfg"
                else
                    Warning "/tmp/custom.cfg file not found"
                fi
            fi
        done
    else
        Warning "$ANA_INSTALL_PATH/boot directory not found"
    fi

    local root_dir=$ANA_INSTALL_PATH/root

    Init_Authorized_Keys "$root_dir/.ssh"

    local log_files="/tmp/syslog /var/tmp/install.pre.log /var/tmp/install.pre.env /var/tmp/install.post.log /var/log/boot.log /var/log/dmesg $curl_tmp_file ${curl_tmp_file}.md5sum"
    for log_file in $log_files; do
        if [ -f "$log_file" ]; then
            _Cp "$log_file" "$LOG_DIR"
        fi
    done

    local remove_files="$root_dir/anaconda-ks.cfg"
    for remove_file in $remove_files; do
        _Rm "$remove_file"
    done

    echo -ne '\007' > /dev/$CONSOLE; sleep 1
    echo -ne '\007' > /dev/$CONSOLE; sleep 1

    Debug "Post_Install() end" 1000
}


function Pre_Install() {
    Debug "Pre_Install() begin" 1000

    if [ "$1" != "" ]; then
        local smartpart="$1"
    else
        local smartpart="$SMARTPART"
    fi

    if [ "$2" != "" ]; then
        local install_disk="$2"
    else
        local install_disk="$INSTALL_DISK"
    fi

    if [ "${install_disk}" == "" ]; then
        Error "install_disk = NULL"
        return
    fi

    local install_device="/dev/${install_disk}"

    if ! _Block_Dev "${install_device}"; then
        Error "${install_device} is not a block device"
    fi

    cat /dev/null > ${smartpart}
    echo "clearpart --none" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${smartpart} initialization succeeded" 2
    else
        Warning "${smartpart} initialization failed [$exit_code]"
    fi

    echo "bootloader --append=\" crashkernel=auto\" --location=mbr --boot-drive=${install_disk}" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${install_device} will contain the bootloader" 3
    else
        Warning "${install_device} will not contain the bootloader" 3
    fi


    local paritition=""
    local partitions=$(ls -1 -d ${install_device}* | grep -v ^${install_device}$)
    local physical_volume=""
    local physical_volumes=""

    physical_volume=$(pvdisplay $install_device 2>&1 | grep VG\ Name | awk '{print $NF}' | grep -v ^Name$)
    if [ "$physical_volume" != "" ]; then
        Debug "existing physical volume on $install_device exists" 4
        physical_volumes+=$physical_volume;
    fi

    if [ "$partitions" == "" ]; then
        Debug "${install_device} has no existing partitions" 3
    else
        Debug "${install_device} has existing partitions" 3

        for partition in $partitions; do
            Debug "$partition" 4
            physical_volume=$(pvdisplay $partition 2>&1 | grep VG\ Name | awk '{print $NF}' | grep -v ^Name$)
            if [ "$physical_volume" != "" ]; then
                Debug "$partition has an existing physical volume named $physical_volume" 4
                physical_volumes+=$physical_volume;
            fi
            physical_volume=""
        done
    fi

    if [ "$physical_volumes" != "" ]; then
        Debug "${install_device} contains the following physical volumes:" 4
        Debug "$physical_volumes" 4

        for physical_volume in $physical_volumes; do
            local physical_volume_lvs=$(lvdisplay $physical_volume | grep LV\ Path | awk '{print $NF}' | grep -v ^Path$)
            for physical_volume_lv in $physical_volume_lvs; do
                lvremove $physical_volume_lv --yes
                local exit_code=$?
                if [ $exit_code -eq 0 ]; then
                    Debug "lvremove $physical_volume_lv from $physical_volume succeeded" 6
                else
                    Warning "lvremove $physical_volume_lv from $physical_volume failed [$exit_code]"
                fi
            done
            physical_volume_lv=""
            vgremove $physical_volume --yes
            local exit_code=$?
            if [ $exit_code -eq 0 ]; then
                Debug "vgremove $physical_volume succeeded" 6
            else
                Warning "vgremove $physical_volume failed [$exit_code]"
            fi
        done
        physical_volume=""

    fi

    Recovery_Media

    Debug "$install_device is being erased (new installation)" 4
    dd if=/dev/zero of=${install_device} bs=512 count=4 &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "dd if=/dev/zero of=$install_device succeeded" 4
    else
        Warning "dd if=/dev/zero of=$install_device failed [$exit_code]"
    fi
    for partition in $partitions; do
        _Rm "$partition"
    done

    partprobe -s ${install_device} &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "partprobe -s ${install_device} succeeded" 3
    else
        Warning "partprobe -s ${install_device} failed [$exit_code]"
    fi

    parted -s ${install_device} mklabel gpt
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "parted -s ${install_device} mklabel gpt succeeded" 3
    else
        Warning "parted -s ${install_device} mklabel gpt failed [$exit_code]"
    fi

    if [ $EFI_STATE -eq 0 ]; then
        local p1mb=256
        local p1name="efi"
        local p2mb=256
        local p2name="recovery"
        local p3mb=512
        local p3name="boot"
        local p4grow="$INSTALL_DISK_PERCENT"
        local p4name=$INSTALL_ID
        local swapmb=2048
    else
        local p1mb=16
        local p1name="bios"
        local p2mb=256
        local p2name="recovery"
        local p3mb=512
        local p3name="boot"
        local p4grow="$INSTALL_DISK_PERCENT"
        local p4name=$INSTALL_ID
        local swapmb=2048
    fi

    sync
    local -i partition_number=1
    local partition_device=${install_device}${partition_number}
    local partition_disk=${install_disk}${partition_number}
    local partition_name=$p1name
    local -i partition_size=$p1mb
    local -i partition_start=1
    local -i partition_end=$partition_start+$partition_size
    if [ "$partition_device" != "" ] && [ "$partition_disk" != "" ] && [ $partition_size -gt 0 ] && [ $partition_start -ne 0 ] && [ $partition_end -gt 1 ]; then
        Debug "$install_device, partition_disk=$partition_disk, start=$partition_start, end=$partition_end, size=$partition_size" 3

        parted -s ${install_device} -a optimal mkpart primary ${partition_start}MiB ${partition_end}MiB
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            if _Block_Dev "${partition_device}"; then
                Debug "${partition_device} partition creation succeeded" 4
            else
                Warning "[1] failed to create partition ${partition_device} [$exit_code]"
            fi
        fi

        parted -s ${install_device} name ${partition_number} "${partition_name}"
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            if _Block_Dev "${partition_device}"; then
                Debug "${partition_device} named '${partition_name}'" 4
            else
                Warning "[1] failed to name ${partition_device} '${partition_name}' [$exit_code]"
            fi
        fi

        parted -s ${install_device} set ${partition_number} boot on
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "${partition_device} set boot on" 4
        else
            Warning "failed set boot on ${partition_device} [$exit_code]"
        fi

        if [ $EFI_STATE -eq 0 ]; then
            echo "part $DIR_EFI_BOOT --fstype=efi --label=${p1name} --onpart=${partition_disk} --size=${partition_size} --noformat" >> ${smartpart}
            local exit_code=$?
            if [ $exit_code -eq 0 ]; then
                Debug "${partition_device} part defined in ${smartpart} (label=$p1name)" 5
            else
                Warning "failed to define part ${partition_device} in ${smartpart} (label=$p1name) [$exit_code]"
            fi

            partprobe -s ${install_device} &> /dev/null
            local exit_code=$?
            if [ $exit_code -eq 0 ]; then
                Debug "$install_device probed" 5
            else
                Warning "failed to probe ${install_device} [$exit_code]"
            fi

            sleep 1;fdisk ${install_device} > /dev/null 2>&1 <<EOF
            t
            1
            w
            q
EOF
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} set partition type to 'EFI System'" 5
else
    Warning "failed to set partition type to 'EFI System' on ${partition_device} [$exit_code]"
fi
else
    echo "part biosboot --fstype=biosboot --label=${p1name} --onpart=${partition_disk} --size=${partition_size} --noformat" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} part defined in ${smartpart} (label=$p1name)" 5
    else
        Warning "failed to define part ${partition_device} in ${smartpart} (label=$p1name) [$exit_code]"
    fi

    partprobe -s ${install_device} &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "$install_device probed" 5
    else
        Warning "failed to probe ${install_device} [$exit_code]"
    fi

    sleep 1;fdisk ${install_device} > /dev/null 2>&1 <<EOF
            t
            4
            w
            q
EOF
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} set partition type to 'biosboot'" 5
else
    Warning "failed to set partition type to 'biosboot' on ${partition_device} [$exit_code]"
fi
fi
fi

mkfs.vfat -F 16 -n "${p1name}" ${partition_device} &> /dev/null
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} vfat filesystem creation succeeded (label=$p1name)" 5
else
    Warning "[2] failed to create vfat filesystem on ${partition_device} (label=$p1name) [$exit_code]"
fi

sync
local -i partition_number=2
local partition_device=${install_device}${partition_number}
local partition_disk=${install_disk}${partition_number}
local partition_name=$p2name
local -i partition_size=$p2mb
local -i partition_start=$partition_end+1
local -i partition_end=$partition_start+$partition_size
if [ "$partition_device" != "" ] && [ "$partition_disk" != "" ] && [ $partition_size -gt 0 ] && [ $partition_start -ne 0 ] && [ $partition_end -gt 1 ]; then
    Debug "$install_device, partition_disk=$partition_disk, start=$partition_start, end=$partition_end, size=$partition_size" 3

    parted -s ${install_device} -a optimal mkpart primary ${partition_start}MiB ${partition_end}MiB
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} partition creation succeeded" 4
        else
            Warning "[3] failed to create partition ${partition_device} [$exit_code]"
        fi
    fi

    parted -s ${install_device} name ${partition_number} "${partition_name}"
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} named '${partition_name}'" 4
        else
            Warning "[2] failed to name ${partition_device} '${partition_name}' [$exit_code]"
        fi
    fi

    partprobe -s ${install_device} &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "$install_device probed" 4
    else
        Warning "failed to probe ${install_device} [$exit_code]"
    fi

    sleep 1;fdisk ${install_device} > /dev/null 2>&1 <<EOF
        t
        ${partition_number}
        12
        w
        q
EOF
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} set partition type to 'Linux filesystem'" 4
else
    Warning "failed to set partition type to 'Linux filesystem' on ${partition_device} [$exit_code]"
fi

local recovery_partition=${partition_device}
echo "part /boot/recovery --fstype=xfs --label=${p1name} --onpart=${partition_disk} --size=${partition_size} --noformat" >> ${smartpart}
mkfs.xfs -q -f -L "${p2name}" ${partition_device} &> /dev/null
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} xfs filesystem creation succeeded (label=$p2name)" 5
else
    Warning "[4] failed to create xfs filesystem on ${partition_device} (label=$p2name) [$exit_code]"
fi

fi


sync
local -i partition_number=3
local partition_device=${install_device}${partition_number}
local partition_disk=${install_disk}${partition_number}
local partition_name=$p3name
local -i partition_size=$p3mb
local -i partition_start=$partition_end+1
local -i partition_end=$partition_start+$partition_size
if [ "$partition_device" != "" ] && [ "$partition_disk" != "" ] && [ $partition_size -gt 0 ] && [ $partition_start -ne 0 ] && [ $partition_end -gt 1 ]; then
    Debug "$install_device, partition_disk=$partition_disk, start=$partition_start, end=$partition_end, size=$partition_size" 3

    parted -s ${install_device} -a optimal mkpart primary ${partition_start}MiB ${partition_end}MiB
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} partition creation succeeded" 4
        else
            Warning "[5] failed to create partition ${partition_device} [$exit_code]"
        fi
    fi

    parted -s ${install_device} name ${partition_number} "${partition_name}"
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} named '${partition_name}'" 4
        else
            Warning "[3] failed to name ${partition_device} '${partition_name}' [$exit_code]"
        fi
    fi

    echo "part /boot --fstype=xfs --label=${p3name} --onpart=${partition_disk} --size=${partition_size}" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} part defined in ${smartpart} (label=$p3name)" 4
    else
        Warning "failed to define part ${partition_device} in ${smartpart} (label=$p3name) [$exit_code]"
    fi

    partprobe -s ${install_device} &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "$install_device probed" 4
    else
        Warning "failed to probe ${install_device} [$exit_code]"
    fi

    sleep 1;fdisk ${install_device} > /dev/null 2>&1 <<EOF
        t
        ${partition_number}
        12
        w
        q
EOF
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} set partition type to 'Linux filesystem'" 4
else
    Warning "failed to set partition type to 'Linux filesystem' on ${partition_device} [$exit_code]"
fi

fi

sync
local -i partition_number=4
local partition_device=${install_device}${partition_number}
local partition_disk=${install_disk}${partition_number}
local partition_name=$p4name
local -i partition_size=$p4grow
local -i partition_start=$partition_end+1
local -i partition_end=$partition_start+$partition_size
if [ "$partition_device" != "" ] && [ "$partition_disk" != "" ] && [ $partition_size -gt 0 ] && [ $partition_start -ne 0 ] && [ $partition_end -gt 1 ]; then
    Debug "$install_device, partition_disk=$partition_disk, start=$partition_start, end=$partition_end, size=$partition_size" 3

    parted -s ${install_device} -a optimal mkpart primary ${partition_start}MiB ${p4grow}%
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} partition creation succeeded" 4
        else
            Warning "[6] failed to create partition ${partition_device} [$exit_code]"
        fi
    fi

    parted -s ${install_device} name ${partition_number} "${partition_name}"
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        if _Block_Dev "${partition_device}"; then
            Debug "${partition_device} named '${partition_name}'" 4
        else
            Warning "[4] failed to name ${partition_device} '${partition_name}' [$exit_code]"
        fi
    fi

    parted -s ${install_device} set ${partition_number} lvm on
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} set lvm on" 4
    else
        Warning "failed set lvm on ${partition_device} [$exit_code]"
    fi

    echo "part pv.01 --fstype=lvmpv --label=${p4name} --onpart=${partition_disk} --size=1 --grow" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} part defined in ${smartpart} (label=$p4name)" 4
    else
        Warning "failed to define part ${partition_device} in ${smartpart} (label=$p4name) [$exit_code]"
    fi

    echo "volgroup os pv.01 --pesize=32768" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} volgroup os pv.01 defined in ${smartpart}" 4
    else
        Warning "${partition_device} failed to define volgroup os pv.01 in ${smartpart} [$exit_code]"
    fi

    echo "logvol swap --fstype=swap --name=swap --vgname=os --size=$swapmb" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} logvol swap defined in ${smartpart}" 4
    else
        Warning "${partition_device} failed to define logvol swap in ${smartpart} [$exit_code]"
    fi

    echo "logvol / --fstype=xfs --name=root --vgname=os --size=1 --grow" >> ${smartpart}
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "${partition_device} logvol / defined in ${smartpart}" 4
    else
        Warning "${partition_device} failed to define logvol / in ${smartpart} [$exit_code]"
    fi

    partprobe -s ${install_device} &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "$install_device probed" 4
    else
        Warning "failed to probe ${install_device} [$exit_code]"
    fi

    sleep 1;fdisk ${install_device} > /dev/null 2>&1 <<EOF
        t
        ${partition_number}
        15
        w
        q
EOF
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "${partition_device} set partition type to 'Linux LVM'" 4
else
    Warning "failed to set partition type to 'Linux LVM' on ${partition_device} [$exit_code]"
fi

fi

if [ ! -s "$smartpart" ]; then
    Error "$smartpart file not found or empty"
fi

Debug_Content "$smartpart"

partprobe -s ${install_device} &> /dev/null
local exit_code=$?
if [ $exit_code -eq 0 ]; then
    Debug "$install_device probed" 2
else
    Warning "failed to probe ${install_device} [$exit_code]"
fi

if [ $DEBUG -gt 100 ]; then
    Debug "output of fdisk -l" 0
    sleep 1;fdisk -l | tee /dev/$CONSOLE
fi

Recovery_Install "$recovery_partition"

echo -ne '\007' > /dev/$CONSOLE; sleep 1

Debug "Pre_Install() end" 1000
}

function Recovery_Install() {
    Debug "Recovery_Install() begin" 1000

    local recovery_partition="$1"

    if [ "$recovery_partition" == "" ]; then
        Warning "recovery partition = NULL"
        return
    fi

    if ! _Block_Dev "${recovery_partition}"; then
        Warning "$recovery_partition is not a block device"
        return
    fi

    local recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")

    if [ "$recovery_media" == "" ]; then
        Warning "$recovery_media is not available"
        return
    fi

    local recovery_device=$(echo "$recovery_partition" | sed -e '/[0-9]/s///g')
    if [ "$recovery_device" == "" ]; then
        recovery_device=/dev/$INSTALL_DISK
    fi

    local -i recovery_partition_number=$(echo "$recovery_partition" | awk -F\/ '{print $NF}' | sed -e "/\/dev\//s///g" -e "/sd[a-z]/s///g")
    if [ "$recovery_partition_number" == "" ] || [ $recovery_partition_number -eq 0 ]; then
        recovery_partition_number=2
    fi

    Debug "recovery_media=$recovery_media, recovery_partition=$recovery_partition ($recovery_device) [$recovery_partition_number]" 2

    if [ -f /etc/grub.d/30_os-prober ]; then
        # workaround for https://bugzilla.redhat.com/show_bug.cgi?id=1275105
        sed -i "/paste -s -d ' '/s//tr ' ' '\\\n'/g" /etc/grub.d/30_os-prober
    fi

    Void "$DIR_RECOVERY"

    mount $recovery_partition $DIR_RECOVERY &> /dev/null
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        Debug "$recovery_partition mounted to $DIR_RECOVERY" 2
    else
        Warning "failed to mount $recovery_partition to $DIR_RECOVERY"
    fi

    for recovery_dir in $RECOVERY_DIRS; do
        if [ "$recovery_dir" != "isolinux" ]; then continue; fi

        rsync -avqp "$recovery_media/$recovery_dir/" "$DIR_RECOVERY/"
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "$DIR_MEDIA/$recovery_dir/ rsync'ed to $DIR_RECOVERY" 2
        else
            Warning "failed to copy $DIR_MEDIA/$recovery_dir/ to $DIR_RECOVERY"
            return
        fi
        date > "$DIR_RECOVERY/$INSTALL_ID"

    done

    local grub2_boot="$DIR_RECOVERY/grub2"

    _Mkdir "$grub2_boot"

    if [ ! -d "$grub2_boot" ]; then
        Warning "$grub2_boot directory not found"
        return
    else
        grub2-mkconfig -o $grub2_boot/grub.cfg &> /dev/null
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "grub2-mkconfig -o $grub2_boot/grub.cfg succeeded" 3
        else
            Warning "grub2-mkconfig -o $grub2_boot/grub.cfg failed [$exit_code]"
        fi

        local grub2_custom_cfg="$grub2_boot/custom.cfg"
        cat /dev/null > "$grub2_custom_cfg"

        #
        # In retrospect, re-install is highly subjective ...
        #

        local -i menu_option_counter=0
        local menu_tab=""
        for menu_option in ${INSTALL_SERVERS[@]}; do
            let menu_option_counter=$menu_option_counter+1

            if [ "$menu_option" != "$INSTALL_DOMAIN" ]; then
                local menu_install_server="${menu_option}.${INSTALL_DOMAIN}"
                local menu_entry="Re-Install from $menu_option"
            else
                local menu_install_server="${INSTALL_DOMAIN}"
                local menu_entry="Re-Install $ACK_LABEL"
                echo "set fallback='$menu_entry'" >> $grub2_custom_cfg
            fi

            Debug "$grub2_custom_cfg updated for $menu_install_server" 4

            local menu_vmlinuz=""
            local menu_initrd=""

            if [ -f /var/log/dmesg ]; then
                local menu_vmlinuz=$(grep inst.ks /var/log/dmesg | grep Command\ line: | awk -Fline: '{print $2}' | sed -e '/\/images\/pxeboot\//s///g' -e '/BOOT_IMAGE=\/vmlinuz/s///g' -e '/initrd=initrd.img/s///g' -e '/^\ /s///g' -e '/^\ /s///g' -e '/^\ /s///g' -e '/\ $/s///g' -e "/$INSTALL_SERVER/s//$menu_install_server/g" -e "/##ACK_INSTALL_SERVER##/s//$menu_install_server/g" -e "/${menu_option}.${menu_option}/s//${menu_option}/g" -e "/BOOT_IMAGE=vmlinuz/s///g" -e "/ $/s///g")
            fi

            if [ $EFI_STATE -eq 0 ]; then
                local initrd="initrdefi"
                local rescue="linuxefi"
                local vmlinuz="linuxefi"
            else
                local initrd="initrd16"
                local rescue="linux16"
                local vmlinuz="linux16"
            fi

            if [ "$menu_vmlinuz" != "" ]; then
                local vmlinuz+=" /vmlinuz $menu_vmlinuz"
                Debug "using vmlinuz (/var/log/dmesg)" 100
            else
                local vmlinuz+=" $(echo "$RECOVERY_VMLINUZ" | sed -e "/$INSTALL_SERVER/s//$menu_install_server/g" -e "/##ACK_INSTALL_SERVER##/s//$menu_install_server/g")"
                Debug "using vmlinuz (default)" 100
            fi

            local initrd+=" $(echo "$RECOVERY_INITRD" | sed -e "/$INSTALL_SERVER/s//$menu_install_server/g" -e "/##ACK_INSTALL_SERVER##/s//$menu_install_server/g")"
            Debug "using initrd (default)" 100


            echo "${menu_tab}menuentry '$menu_entry' --class $INSTALL_ID --class gnu-linux --class gnu --class os --class $ACK_LABEL {" >> $grub2_custom_cfg
            echo "${menu_tab}    insmod gzio" >> $grub2_custom_cfg
            echo "${menu_tab}    insmod part_gpt" >> $grub2_custom_cfg
            echo "${menu_tab}    insmod xfs" >> $grub2_custom_cfg
            # it's a fairly safe assumption, but how can we be absolutely sure hd0 is the recovery disk??
            echo "${menu_tab}    set root='hd0,gpt${recovery_partition_number}'" >> $grub2_custom_cfg
            echo "${menu_tab}    $vmlinuz" >> $grub2_custom_cfg
            echo "${menu_tab}    $initrd" >> $grub2_custom_cfg
            echo "${menu_tab}}" >> $grub2_custom_cfg
            echo >> $grub2_custom_cfg

            if [ $menu_option_counter -eq 1 ]; then
                echo "${menu_tab}submenu '.' {" >> $grub2_custom_cfg
                echo >> $grub2_custom_cfg
                local menu_tab="    "
                echo "${menu_tab}menuentry 'rescue-remote' --class fedora --class gnu-linux --class gnu --class os --class $ACK_LABEL {" >> $grub2_custom_cfg
                echo "${menu_tab}    insmod gzio" >> $grub2_custom_cfg
                echo "${menu_tab}    insmod part_gpt" >> $grub2_custom_cfg
                echo "${menu_tab}    insmod xfs" >> $grub2_custom_cfg
                echo "${menu_tab}    set root='hd0,gpt${recovery_partition_number}'" >> $grub2_custom_cfg
                echo "${menu_tab}    $rescue /vmlinuz inst.ks.sendmac inst.ks.sendsn inst.stage2=https://$menu_install_server/rescue noverifyssl inst.sshd console=##ACK_CLIENT_CONSOLE## rescue inst.syslog=$menu_install_server" >> $grub2_custom_cfg
                echo "${menu_tab}    $initrd" >> $grub2_custom_cfg
                echo "${menu_tab}}" >> $grub2_custom_cfg
                echo >> $grub2_custom_cfg
            fi
        done
        if [ $menu_option_counter -ge 1 ]; then
            echo "}" >> $grub2_custom_cfg
        fi

        if [ ! -s "${grub2_custom_cfg}" ]; then
            Warning "$grub2_custom_cfg file not found or empty"
        else
            _Cp "${grub2_custom_cfg}" /tmp
            Debug_Content "${grub2_custom_cfg}"
        fi

    fi

    if [ $EFI_STATE -eq 0 ]; then
        local efi_boot=$DIR_EFI_BOOT
        local efi_boot_nums=$(efibootmgr | grep ^Boot[0-9] | awk '{print $1}' | sed -e '/\*/s///g' -e '/Boot/s///g')
        local efi_partition=${recovery_device}1

        for efi_boot_num in $efi_boot_nums; do
            efibootmgr --bootnum $efi_boot_num --delete-bootnum &> /dev/null
            local exit_code=$?
            if [ $exit_code -eq 0 ]; then
                Debug "efibootmgr --bootnum $efi_boot_num --delete-bootnum succeeded" 4
            else
                Warning "efibootmgr --bootnum $efi_boot_num --delete-bootnum failed [$exit_code]"
            fi
        done

        Void "$efi_boot"

        local grub2_install_options="--recheck --target=$GRUB2_TARGET $recovery_partition --boot-directory=$DIR_RECOVERY --efi-directory=$efi_boot --bootloader-id=recovery"

        mount $efi_partition $efi_boot &> /dev/null
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "$efi_partition mounted to $efi_boot" 2
        else
            Warning "failed to mount $efi_partition to $efi_boot"
            return
        fi

    else
        local grub2_install_options="--recheck --target=$GRUB2_TARGET $recovery_device --boot-directory=$DIR_RECOVERY"
    fi

    if [ -b "$recovery_device" ] && [ -d "$DIR_RECOVERY" ]; then
        Debug "grub2-install $grub2_install_options" 400
        grub2-install $grub2_install_options &> /dev/null
        local exit_code=$?
        if [ $exit_code -eq 0 ]; then
            Debug "grub2-install $grub2_install_options succeeded" 300
        else
            Debug "grub2-install $grub2_install_options failed [$exit_code]"
        fi
    fi

    if [ $EFI_STATE -eq 0 ]; then
        Void "$efi_boot"
    fi

    Void "$DIR_RECOVERY"

    Debug "Recovery_Install() end" 1000
}

function Recovery_Media() {
    Debug "Recovery_Media() begin" 1000

    local recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")
    local recovery_source=""

    if [ "$recovery_media" == "" ]; then

        local search_devices
        search_devices+="/dev/cdrom"
        search_devices+=" "
        search_devices+="$(echo /dev/sr{0..9})"
        search_devices+=" "
        search_devices+="$SUPPORTED_DEVICES"

        Debug "search_devices = $search_devices" 5

        for search_device in $search_devices; do
            if [ "$recovery_media" != "" ]; then continue; fi

            Void "$DIR_MEDIA"

            if [ -b $search_device ] || [ -f $search_device ] || [ -h $search_device ]; then

                mount $search_device $DIR_MEDIA &> /dev/null
                local exit_code=$?
                if [ $exit_code -ne 0 ]; then
                    Debug "NOTICE, could not mount $search_device" 5
                fi

            fi

            recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")
            if [ "$recovery_media" != "" ]; then
                recovery_source=$search_device
            fi

        done

    fi

    if [ "$recovery_media" == "" ]; then
        Void "$DIR_MEDIA"

        for recovery_dir in $RECOVERY_DIRS; do
            local recovery_basename="${recovery_dir}.md5sum"
            local recovery_dirname="$DIR_MEDIA/$recovery_dir"
            local recovery_filename="$recovery_dirname/$recovery_basename"
            #local recovery_url="https://$INSTALL_SERVER/$recovery_dir/$recovery_basename"
            local recovery_url="${DEFAULT_CLIENT_BUILD_URL}/$recovery_dir/$recovery_basename"

            _Mkdir "$recovery_dirname"

            if [ ! -d "$recovery_dirname" ]; then
                Warning "$recovery_dirname directory not found"
                return
            fi

            local http_code=$(eval curl $CURL_HEADERS --write-out %{http_code} --silent -k $recovery_url -o $recovery_filename)
            if [ "$http_code" == "200" ]; then
                Debug "curled $recovery_url" 3
                if [ ! -f "$recovery_filename" ]; then
                    touch "$recovery_filename"
                    local exit_code=$?
                    if [ $exit_code -eq 0 ]; then
                        Debug "$recovery_filename touched" 3
                    else
                        Warning "failed to touch $recovery_filename [$exit_code]"
                        return
                    fi
                fi
                if [ "$recovery_source" == "" ]; then
                    recovery_source=$recovery_url
                else
                    recovery_source+=" AND $recovery_url"
                fi
            else
                Warning "failed to curl $recovery_url"
                _Rm "$recovery_filename"
                return
            fi

            local recovery_basename=""
            local recovery_dirname=""
            local recovery_filename=""
            local recovery_url=""
        done

        recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")

        if [ "$recovery_media" == "" ]; then
            Warning "recovery media md5sums are missing (1)"
            return
        else
            Debug "curled recovery media md5sums are in $recovery_media" 3
            for recovery_dir in $RECOVERY_DIRS; do
                local recovery_md5sum_filename="$recovery_media/$recovery_dir/${recovery_dir}.md5sum"

                if [ -f "$recovery_md5sum_filename" ]; then
                    Debug "evaluating $recovery_md5sum_filename" 4

                    local recovery_md5sums=$(cat "$recovery_md5sum_filename" | awk '{print $NF}')

                    for recovery_md5sum in $recovery_md5sums; do
                        local recovery_basename="$(basename "$recovery_md5sum")"
                        local recovery_dirname="$recovery_media/$recovery_dir/$(dirname $recovery_md5sum)"
                        local recovery_filename="$recovery_dirname/$recovery_basename"
                        local recovery_url="https://$INSTALL_SERVER/$recovery_dir/$recovery_md5sum"

                        Debug "validating $recovery_filename" 5

                        _Mkdir "$recovery_dirname"

                        if [ ! -d "$recovery_dirname" ]; then
                            Warning "$recovery_dirname directory not found"
                            return
                        fi

                        if [ ! -f "$recovery_file" ]; then
                            local http_code=$(eval curl $CURL_HEADERS --write-out %{http_code} --silent -k $recovery_url -o $recovery_filename)
                            if [ "$http_code" == "200" ]; then
                                Debug "curled $recovery_url" 6
                            else
                                Warning "failed to curl $recovery_url"
                                _Rm "$recovery_filename"
                                return
                            fi
                        else
                            Debug "$recovery_filename file found" 5
                        fi

                        local recovery_basename=""
                        local recovery_dirname=""
                        local recovery_filename=""
                        local recovery_url=""
                    done
                else
                    recovery_media=""
                    Warning "$recovery_md5sum_filename file not found"
                    return
                fi

                local recovery_md5sum_filename=""
            done
        fi
    fi

    recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")

    if [ "$recovery_media" == "" ]; then
        Warning "recovery media md5sums are missing (2)"
        return
    else
        for recovery_dir in $RECOVERY_DIRS; do
            local recovery_md5sum_filename="$recovery_media/$recovery_dir/${recovery_dir}.md5sum"

            if [ -f "$recovery_md5sum_filename" ]; then
                Debug "verifying $recovery_md5sum_filename" 4

                local recovery_md5sums=$(cat "$recovery_md5sum_filename" | awk '{print $NF}')

                for recovery_md5sum in $recovery_md5sums; do
                    local recovery_basename="$(basename "$recovery_md5sum")"
                    local recovery_dirname="$recovery_media/$recovery_dir/$(dirname $recovery_md5sum)"
                    local recovery_filename="$recovery_dirname/$recovery_basename"

                    if [ ! -f "$recovery_filename" ]; then
                        recovery_media=""
                        Error "failed to find $recovery_filename"
                    fi

                    recovery_md5sum_expected=$(cat "$recovery_md5sum_filename" | grep "\ ${recovery_md5sum}$" | awk '{print $1}')
                    recovery_md5sum_actual=$(md5sum $recovery_filename | awk '{print $1}')

                    if [ "$recovery_md5sum_expected" == "$recovery_md5sum_actual" ] && [ "$recovery_md5sum_actual" != "" ]; then
                        Debug "verified md5sum of $recovery_filename" 4
                    else
                        recovery_media=""
                        Error "failed to match md5sum for $recovery_filename ($recovery_md5sum_expected != $recovery_md5sum_actual)"
                    fi

                    if [ "$recovery_source" == "" ]; then
                        recovery_source=$recovery_media
                    fi

                    local recovery_basename=""
                    local recovery_dirname=""
                    local recovery_filename=""
                done
            else
                recovery_media=""
                Warning "$recovery_md5sum_filename file not found"
                return
            fi

            local recovery_md5sum_filename=""
        done
    fi

    if [ "$recovery_source" != "" ]; then
        Debug "$recovery_source is the recovery source" 2
    else
        Warning "recovery_source = NULL"
        return
    fi

    # workaround for https://bugzilla.redhat.com/show_bug.cgi?id=1277227
    if [ ! -d "/usr/lib/grub/$GRUB2_TARGET" ]; then
        local grub2_target_media=$recovery_media/grub/usr-lib-grub-${GRUB2_TARGET}.tar.gz
        if [ -f "$grub2_target_media" ]; then
            Debug "$grub2_target_media file found" 3
            tar -C / -zxf "$grub2_target_media"
            local exit_code=$?
            if [ $exit_code -eq 0 ]; then
                Debug "$grub2_target_media untarred" 3
            else
                Warning "failed to untar $grub2_target_media [$exit_code]"
                return
            fi
        else
            Debug "$grub2_target_media file not found" 3
        fi
    fi

    if [ ! -d "/usr/lib/grub/$GRUB2_TARGET" ]; then
        Error "/usr/lib/grub/$GRUB2_TARGET directory not found"
    else
        Debug "/usr/lib/grub/$GRUB2_TARGET directory found" 2
    fi

    recovery_media=$(Recovery_Media_Search "$DIR_MEDIA")

    if [ "$recovery_media" == "" ]; then
        Error "recovery media md5sums are missing (3)" 3
    fi

    Debug "Recovery_Media() end" 1000
}

function Recovery_Media_Search() {
    Debug "Recovery_Media_Search() begin" 1000

    local recovery_dir=""
    local -i recovery_state=0
    if [ "$1" == "" ]; then
        local search_dir="$DIR_MEDIA"
    else
        local search_dir="$1"
    fi

    if [ ! -d "$search_dir" ]; then return; fi

    for recovery_dir in $RECOVERY_DIRS; do
        if [ $recovery_state -eq 0 ] || [ $recovery_state -eq 2 ]; then
            if [ -f "$search_dir/$recovery_dir/${recovery_dir}.md5sum" ]; then
                recovery_state=2
            else
                Debug "$search_dir/$recovery_dir/${recovery_dir}.md5sum file not found" 102 1>&2
                recovery_state=1
            fi
        fi
    done

    if [ $recovery_state -eq 2 ]; then
        echo "$search_dir"
    fi

    Debug "Recovery_Media_Search() end" 1000
}

function Url_Encode() {
    Debug "Url_Encode() begin" 1000

    if [ "$1" == "" ]; then return; fi

    echo "$1" | sed \
        -e "s:%:%25:g" \
        -e "s: :%20:g" \
        -e "s:<:%3C:g" \
        -e "s:>:%3E:g" \
        -e "s:#:%23:g" \
        -e "s:{:%7B:g" \
        -e "s:}:%7D:g" \
        -e "s:|:%7C:g" \
        -e "s:\\\:%5C:g" \
        -e "s:\\^:%5E:g" \
        -e "s:~:%7E:g" \
        -e "s:\\[:%5B:g" \
        -e "s:\\]:%5D:g" \
        -e "s:\`:%60:g" \
        -e "s:;:%3B:g" \
        -e "s:/:%2F:g" \
        -e "s:?:%3F:g" \
        -e "s^:^%3A^g" \
        -e "s:@:%40:g" \
        -e "s:=:%3D:g" \
        -e "s:&:%26:g" \
        -e "s:\\$:%24:g" \
        -e "s:\\!:%21:g" \
        -e "s:\\*:%2A:g"

    Debug "Url_Encode() end" 1000
}

function Void() {
    Debug "Void() begin" 1000

    if [ "$1" == "" ]; then
        local blanks="$EPHEMERAL_DIRS"
        if [ $INSTALL_STATE -eq 1 ] && [ "$INSTALL_DISK" != "" ]; then
            local install_devices=$(mount | grep /dev/$INSTALL_DISK | awk '{print $1}')
            for install_device in $install_devices; do
                umount -f $install_device &> /dev/null
                local exit_code=$?
                if [ $exit_code -eq 32 ]; then
                    Debug "$install_device device not mounted" 200
                else
                    if [ $exit_code -eq 0 ]; then
                        Debug "$install_device device unmounted" 5
                    else
                        Warning "failed to unmount device $install_device [$exit_code]"
                    fi
                fi
            done
        fi
    else
        local blanks="$1"
    fi

    if [ "$2" == "" ]; then
        local initialize_state=1
    else
        local initialize_state=0
    fi

    for blank in $blanks; do
        if [ -b "$blank" ] || [ -h "$blank" ] || [ -f "$blank" ]; then
            _Rm "$blank"
            continue
        fi

        if [ -d "$blank" ]; then
            umount -f $blank &> /dev/null
            local exit_code=$?
            if [ $exit_code -eq 32 ]; then
                Debug "$blank directory not mounted" 200
            else
                if [ $exit_code -eq 0 ]; then
                    Debug "$blank directory unmounted" 5
                else
                    Warning "failed to unmount directory $blank [$exit_code]"
                fi
            fi

            _Rm "$blank"
        fi

        if [ $initialize_state -eq 1 ]; then
            _Mkdir "$blank"
        fi

    done

    sync && echo 3 > /proc/sys/vm/drop_caches

    Debug "Void() end" 1000
}

function Warning() {
    Debug "Warning() begin" 1000

    let WARNING_COUNT=$WARNING_COUNT+1
    if [ "$1" != "" ]; then
        Debug "" 0
        Debug "[$RETRY_COUNT/$WARNING_COUNT] WARNING, $1" 0
        Debug "" 0
    fi

    Debug "Warning() end" 1000
}

Init_Ack

if [ $WARNING_COUNT -gt 0 ]; then
    while [ $RETRY_COUNT -lt $RETRY_MAXIMUM ] && [ $WARNING_COUNT -ne 0 ]; do
        let RETRY_COUNT=$RETRY_COUNT+1
        INSTALL_STATE=0
        WARNING_COUNT=0
        Init_Ack
    done
fi

if [ $RETRY_COUNT -ge $RETRY_MAXIMUM ] || [ $INSTALL_STATE -le 0 ] || [ $INSTALL_STATE -ge 3 ]; then
    INSTALL_STATE_NAME="init install"

    Error "$INSTALL_STATE_NAME failed"
fi

if [ $INSTALL_STATE -eq 1 ]; then
    INSTALL_STATE_NAME="pre install"

    ANA_INSTALL_DIRS="/tmp"

    LOG_DIR="/var/tmp"
    LOG_ENV="$LOG_DIR/install.pre.env"
fi

if [ $INSTALL_STATE -eq 2 ]; then
    INSTALL_STATE_NAME="post install"

    ANA_INSTALL_DIRS="$ANA_INSTALL_PATH/bin $ANA_INSTALL_PATH/boot/grub2 $ANA_INSTALL_PATH/etc $ANA_INSTALL_PATH/sbin $ANA_INSTALL_PATH/usr/bin $ANA_INSTALL_PATH/usr/sbin $ANA_INSTALL_PATH/var/tmp"

    LOG_DIR="$ANA_INSTALL_PATH/var/tmp/ack"
    LOG_ENV="$LOG_DIR/install.post.env"

fi

Debug "" 0
Debug "install state $INSTALL_STATE : $INSTALL_STATE_NAME started" 0
Debug "" 0

if [ "$ANA_INSTALL_DIRS" == "" ] || [ "$LOG_DIR" == "" ]; then
    Error "directory dependency checks failed"
fi

for ANA_INSTALL_DIR in $ANA_INSTALL_DIRS; do
    if [ ! -d "$ANA_INSTALL_DIR" ]; then
        Error "$ANA_INSTALL_DIR directory not found"
    else
        Debug "$ANA_INSTALL_DIR directory found" 2
    fi
done

_Mkdir "$LOG_DIR"

if [ ! -f "$LOG_ENV" ]; then
    env > "$LOG_ENV"
    exit_code=$?
    if [ $exit_code -ne 0 ]; then
        Error "can't log environment in $LOG_ENV"
    else
        Debug "logged environment in $LOG_ENV" 2
    fi
else
    Debug "$LOG_ENV preserved" 1
fi

if [ $INSTALL_STATE -eq 1 ]; then
    Recovery_Media
    if [ $WARNING_COUNT -gt 0 ]; then
        while [ $RETRY_COUNT -lt $RETRY_MAXIMUM ] && [ $WARNING_COUNT -ne 0 ]; do
            let RETRY_COUNT=$RETRY_COUNT+1
            WARNING_COUNT=0
            Recovery_Media
        done
    fi

    if [ $WARNING_COUNT -eq 0 ]; then
        Pre_Install
        if [ $WARNING_COUNT -gt 0 ]; then
            while [ $RETRY_COUNT -lt $RETRY_MAXIMUM ] && [ $WARNING_COUNT -ne 0 ]; do
                let RETRY_COUNT=$RETRY_COUNT+1
                WARNING_COUNT=0
                Pre_Install
            done
        fi
    fi
fi

if [ $INSTALL_STATE -eq 2 ]; then
    Post_Install
    if [ $WARNING_COUNT -gt 0 ]; then
        while [ $RETRY_COUNT -lt $RETRY_MAXIMUM ] && [ $WARNING_COUNT -ne 0 ]; do
            let RETRY_COUNT=$RETRY_COUNT+1
            WARNING_COUNT=0
            Post_Install
        done
    fi
fi

if [ $EFI_STATE -eq 0 ]; then
    Void "$DIR_EFI_BOOT" false
fi

Void "$EPHEMERAL_DIRS" false

Debug "" 0
Debug "install state $INSTALL_STATE : $INSTALL_STATE_NAME finished in $SECONDS seconds ($WARNING_COUNT warnings, $RETRY_COUNT retries)" 0
Debug "" 0

if [ $RETRY_COUNT -ge $RETRY_MAXIMUM ]; then
    Error "install state $INSTALL_STATE : failed"
else
    if [ $INSTALL_STATE -eq 2 ] && [ $DEBUG -eq 0 ]; then
        _Reboot
    else
        exit 0
    fi
fi
